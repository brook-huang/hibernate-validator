<?xml version="1.0" encoding="UTF-8"?>
<!--
	~ JBoss, Home of Professional Open Source
	~ Copyright 2013, Red Hat, Inc. and/or its affiliates, and individual contributors
	~ by the @authors tag. See the copyright.txt in the distribution for a
	~ full listing of individual contributors.
	~
	~ Licensed under the Apache License, Version 2.0 (the "License");
	~ you may not use this file except in compliance with the License.
	~ You may obtain a copy of the License at
	~ http://www.apache.org/licenses/LICENSE-2.0
	~ Unless required by applicable law or agreed to in writing, software
	~ distributed under the License is distributed on an "AS IS" BASIS,
	~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	~ See the License for the specific language governing permissions and
	~ limitations under the License.
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../hv.ent">
%BOOK_ENTITIES;
]>
<chapter id="validator-usingvalidator">
  <title>Declaring and validating method constraints</title>

  <para>In this chapter we will see in more detail how to use Hibernate
  Validator to validate constraints for a given entity model. We will also
  learn which default constraints the Bean Validation specification provides
  and which additional constraints are only provided by Hibernate Validator.
  Let's start with how to add constraints to an entity.</para>

  <section id="validator-usingvalidator-annotate">
    <title>Defining constraints</title>

    <para>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to enhance an object model with these
    annotations. We have to differentiate between several types of constraint
    annotations:</para>

    <para><itemizedlist>
        <listitem>
          <para>field constraints</para>
        </listitem>

        <listitem>
          <para>property constraints</para>
        </listitem>

        <listitem>
          <para>class constraints</para>
        </listitem>

        <listitem>
          <para>method constraints (parameter, cross-parameter and return
          value constraints)</para>
        </listitem>
      </itemizedlist></para>

    <note>
      <para>Not all constraints can be placed on all of these levels. In fact,
      none of the default constraints defined by Bean Validation can be placed
      at class level. The <classname>java.lang.annotation.Target</classname>
      annotation in the constraint annotation itself determines on which
      elements a constraint can be placed. See <xref
      linkend="validator-customconstraints"/> for more information.</para>
    </note>

    <section>
      <title>Field-level constraints</title>

      <para>Constraints can be expressed by annotating a field of a class.
      <xref linkend="example-field-level"/> shows a field level configuration
      example:</para>

      <example id="example-field-level">
        <title>Field level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    private String manufacturer;

    @AssertTrue
    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using field level constraints field access strategy is used
      to access the value to be validated. This means the bean validation
      provider directly accesses the instance variable and does not invoke the
      property accessor method also if such a method exists.</para>

      <note>
        <para>The access type (private, protected or public) does not
        matter.</para>
      </note>

      <note>
        <para>Static fields and properties cannot be validated.</para>
      </note>

      <tip>
        <para>When validating byte code enhanced objects property level
        constraints should be used, because the byte code enhancing library
        won't be able to determine a field access via reflection.</para>
      </tip>
    </section>

    <section>
      <title>Property-level constraints</title>

      <para>If your model class adheres to the <ulink type=""
      url="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</ulink>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <xref linkend="example-property-level"/> uses the
      same entity as in <xref linkend="example-field-level"/>, however,
      property level constraints are used.<note>
          <para>The property's getter method has to be annotated, not its
          setter.</para>
        </note></para>

      <example id="example-property-level">
        <title>Property level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;

    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    @NotNull
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    @AssertTrue
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method. One
      advantage of annotating properties instead of fields is that the
      constraints become part of the constrained type's API that way and users
      are aware of the existing constraints without having to examine the
      type's implementation.</para>

      <tip>
        <para>It is recommended to stick either to field
        <emphasis>or</emphasis> property annotations within one class. It is
        not recommended to annotate a field <emphasis>and</emphasis> the
        accompanying getter method as this would cause the field to be
        validated twice.</para>
      </tip>
    </section>

    <section>
      <title id="validator-usingvalidator-classlevel">Class-level
      constraints</title>

      <para>Last but not least, a constraint can also be placed on class
      level. When a constraint annotation is placed on this level the class
      instance itself passed to the
      <classname>ConstraintValidator</classname>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In <xref linkend="example-class-level"/>
      we add the property <property>passengers</property> to the class
      <classname>Car</classname>. We also add the constraint
      <classname>PassengerCount</classname> on the class level. We will later
      see how we can actually create this custom constraint (see <xref
      linkend="validator-customconstraints"/>). For now it is enough to know
      that <classname>PassengerCount</classname> will ensure that there cannot
      be more passengers in a car than there are seats.</para>

      <example id="example-class-level">
        <title>Class level constraint</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

@PassengerCount
public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    private List&lt;Person&gt; passengers;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</programlisting>
      </example>
    </section>

    <section>
      <title id="validator-usingvalidator-classlevel">Method
      constraints</title>

      <para>TODO - intro</para>

      <section>
        <title>Parameter constraints</title>

        <para/>
      </section>

      <section>
        <title>Cross-parameter constraints</title>

        <para/>
      </section>

      <section>
        <title>Return value constraints</title>

        <para/>
      </section>
    </section>

    <section>
      <title>Constraint inheritance</title>

      <para>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</para>

      <example>
        <title>Constraint inheritance using RentalCar</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;

    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }

    @NotNull
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</programlisting>
      </example>

      <para>Our well-known class <classname>Car</classname> is now extended by
      <classname>RentalCar</classname> with the additional property
      <property>rentalStation</property>. If an instance of
      <classname>RentalCar</classname> is validated, not only the
      <classname>@NotNull</classname> constraint on
      <property>rentalStation</property> is validated, but also the constraint
      on <property>manufacturer</property> from the parent class.</para>

      <para>The same would hold true, if <classname>Car</classname> were an
      interface implemented by <classname>RentalCar</classname>.</para>

      <para>Constraint annotations are aggregated if methods are overridden.
      If <classname>RentalCar</classname> would override the
      <methodname>getManufacturer()</methodname> method from
      <classname>Car</classname> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <classname>@NotNull</classname> constraint from the super-class.</para>
    </section>

    <section>
      <title>Object graphs</title>

      <para>The Bean Validation API does not only allow to validate single
      class instances but also complete object graphs. To do so, just annotate
      a field or property representing a reference to another object with
      <classname>@Valid</classname>. If the parent object is validated, all
      referenced objects annotated with <classname>@Valid</classname> will be
      validated as well (as will be their children etc.). See <xref
      linkend="example-car-with-driver"/>.</para>

      <example>
        <title>Class Person</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    @NotNull
    private String name;

    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</programlisting>
      </example>

      <example id="example-car-with-driver">
        <title>Adding a driver to the car</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    @Valid
    private Person driver;

    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If an instance of <classname>Car</classname> is validated, the
      referenced <classname>Person</classname> object will be validated as
      well, as the <property>driver</property> field is annotated with
      <classname>@Valid</classname>. Therefore the validation of a
      <classname>Car</classname> will fail if the <property>name</property>
      field of the referenced <classname>Person</classname> instance is
      <code>null</code>.</para>

      <para>Object graph validation also works for collection-typed fields.
      That means any attributes that</para>

      <itemizedlist>
        <listitem>
          <para>are arrays</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.lang.Iterable</classname>
          (especially <classname>Collection</classname>,
          <classname>List</classname> and <classname>Set</classname>)</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.util.Map</classname></para>
        </listitem>
      </itemizedlist>

      <para>can be annotated with <classname>@Valid</classname>, which will
      cause each contained element to be validated, when the parent object is
      validated.</para>

      <example>
        <title>Car with a list of passengers</title>

        <programlisting language="JAVA" role="JAVA">package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    @Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If a <classname>Car</classname> instance is validated, a
      <classname>ConstraintValidation</classname> will be created, if any of
      the <classname>Person</classname> objects contained in the
      <property>passengers</property> list has a <code>null</code> name.<note>
          <para><classname>null</classname> values are getting ignored when
          validating object graphs.</para>
        </note></para>
    </section>
  </section>

  <section id="validator-usingvalidator-validate">
    <title>Validating constraints</title>

    <para>The <classname>Validator</classname> interface is the main entry
    point to Bean Validation. In <xref linkend="section-validator-instance"/>
    we will first show how to obtain an <classname>Validator</classname>
    instance. Afterwards we will learn how to use the different methods of the
    <classname>Validator</classname> interface.</para>

    <section id="section-obtaining-validator">
      <title>Obtaining a <classname>Validator</classname> instance</title>

      <para>The first step towards validating an entity instance is to get
      hold of a <classname>Validator</classname> instance. The road to this
      instance leads via the <classname>Validation</classname> class and a
      <classname>ValidatorFactory</classname>. The easiest way is to use the
      static
      <methodname>Validation.buildDefaultValidatorFactory()</methodname>
      method:</para>

      <example>
        <title>Validation.buildDefaultValidatorFactory()</title>

        <programlisting language="JAVA" role="JAVA">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();</programlisting>
      </example>

      <para>For other ways of obtaining a Validator instance see <xref
      linkend="validator-bootstrapping"/>. For now we just want to see how we
      can use the <classname>Validator</classname> instance to validate entity
      instances.</para>
    </section>

    <section>
      <title>Validator methods</title>

      <para>The <classname>Validator</classname> interface contains three
      methods that can be used to either validate entire entities or just a
      single properties of the entity.</para>

      <para>All three methods return a
      <classname>Set&lt;ConstraintViolation&gt;</classname>. The set is empty,
      if the validation succeeds. Otherwise a
      <classname>ConstraintViolation</classname> instance is added for each
      violated constraint.</para>

      <para>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified the default
      validation group
      (<classname>javax.validation.groups.Default</classname>) will be used.
      We will go into more detail on the topic of validation groups in <xref
      linkend="validator-usingvalidator-validationgroups"/></para>

      <section>
        <title><methodname>validate</methodname></title>

        <para>Use the <methodname>validate()</methodname> method to perform
        validation of all constraints of a given entity instance (see <xref
        linkend="example-validator-validate"/> ).</para>

        <example id="example-validator-validate">
          <title>Usage of
          <methodname>Validator.validate()</methodname></title>

          <programlisting language="JAVA" role="JAVA">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(car);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>
      </section>

      <section>
        <title><methodname>validateProperty</methodname></title>

        <para>With help of the <methodname>validateProperty()</methodname> a
        single named property of a given object can be validated. The property
        name is the JavaBeans property name.</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateProperty()</methodname></title>

          <programlisting language="JAVA" role="JAVA">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(car, "manufacturer");

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <para><methodname>Validator.validateProperty</methodname> is for
        example used in the integration of Bean Validation into JSF 2 (see
        <xref linkend="section-presentation-layer"/>).</para>
      </section>

      <section>
        <title><methodname>validateValue</methodname></title>

        <para>Using the <methodname>validateValue() </methodname>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</para>

        <example>
          <title>Usage of
          <methodname>Validator.validateValue()</methodname></title>

          <programlisting language="JAVA" role="JAVA">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(Car.class, "manufacturer", null);

assertEquals(1, constraintViolations.size());
assertEquals("may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
        </example>

        <note>
          <para><classname>@Valid</classname> is not honored by
          <methodname>validateProperty()</methodname> or
          <methodname>validateValue()</methodname>.</para>
        </note>
      </section>
    </section>

    <section>
      <title><classname>ConstraintViolation</classname> methods</title>

      <para>Now it is time to have a closer look at what a
      <classname>ConstraintViolation</classname>. Using the different methods
      of <classname>ConstraintViolation</classname> a lot of useful
      information about the cause of the validation failure can be determined.
      <xref linkend="table-constraint-violation"/> gives an overview of these
      methods:</para>

      <table id="table-constraint-violation">
        <title>The various <classname>ConstraintViolation</classname>
        methods</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Method</entry>

              <entry>Usage</entry>

              <entry>Example (referring to <xref
              linkend="example-validator-validate"/>)</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><methodname>getMessage()</methodname></entry>

              <entry>The interpolated error message.</entry>

              <entry>may not be null</entry>
            </row>

            <row>
              <entry><methodname>getMessageTemplate()</methodname></entry>

              <entry>The non-interpolated error message.</entry>

              <entry>{javax.validation.constraints.NotNull.message}</entry>
            </row>

            <row>
              <entry><methodname>getRootBean()</methodname></entry>

              <entry>The root bean being validated.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getRootBeanClass()</methodname></entry>

              <entry>The class of the root bean being validated.</entry>

              <entry>Car.class</entry>
            </row>

            <row>
              <entry><methodname>getLeafBean()</methodname></entry>

              <entry>If a bean constraint, the bean instance the constraint is
              applied on. If a property constraint, the bean instance hosting
              the property the constraint is applied on.</entry>

              <entry>car</entry>
            </row>

            <row>
              <entry><methodname>getPropertyPath()</methodname></entry>

              <entry>The property path to the value from root bean.</entry>

              <entry/>
            </row>

            <row>
              <entry><methodname>getInvalidValue()</methodname></entry>

              <entry>The value failing to pass the constraint.</entry>

              <entry>passengers</entry>
            </row>

            <row>
              <entry><methodname>getConstraintDescriptor()</methodname></entry>

              <entry>Constraint metadata reported to fail.</entry>

              <entry/>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>
</chapter>
